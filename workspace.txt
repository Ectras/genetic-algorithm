* Genes?
  * [v] Store best_genes on Genotype, copy genes on storing best chromosome (solve M+2 issue)
  * [ ] Remove empty chromomsome concept, just use Options again in the code (much cleaner)
  * [v] Change Chromosome<Genotype> to Genotype::Chromosome
  * [v] Change Population<Genotype> to Population<Chromosome>
  * [ ] Check fitness API

  * External genes are always Vec<Allele> (seed and best_genes). Internal genes can be anything
  * Alway use best_genes as result. Still allow best chromomsome, but note the genes are internal
  * Rename genes on chromosome to data? Would affect calculate_for_chromosome API, so maybe no. User needs to know the difference anyway
  * Remove need for working chromomsome, by just copying the chromomsome over the existing best? copy(&src, &mut dest), but would still need to clone if empty
  * Store best chromosome separately in StaticMatrixGenotype (as [T; N]), so population == M?
  * Discourage use of best-chromosome in API

  * reduce number of Chromosome types (multi is same as single, static and dynamic are same as well)

* Store staticMatrixGenotype on heap using Box?
* Extensions benchmark is noisy
* Distinction between poplation, offspring, parent cardinality (as offspring is always freshly mutated, generating cardinality, while the parents could all be equal)
* Chunk parallel iters for less switching?
* Document GenotypeBuilder
* Stochastic secondary: swap best gene with working gene, so secondary gene is no longer there to mutate on? check



const GENES_SIZE: usize = 4100;
const POPULATION_SIZE: usize = 100;
!!! Bordering stack overflow !!!


const GENES_SIZE: usize = 4000;
const POPULATION_SIZE: usize = 100;

   MatrixGenotype::<f32, GENES_SIZE, { POPULATION_SIZE + 1 }> nalgebra
      finish - iteration: 0
        Init: 695.91µs
        Select: 8.690551ms
        Crossover: 34.889828ms
        Mutate: 2.877416ms
        Fitness: 610.161µs
        UpdateBestChromosome: 702.403µs
        Other: 3.183911ms
        Total: 51.65018ms

   MatrixGenotype::<f32, GENES_SIZE, { POPULATION_SIZE + 1 }> plain => nalgebra adds no overhead, even when iterating swap.
    finish - iteration: 0
      Init: 882.161µs
      Select: 9.849975ms
      Crossover: 37.083578ms
      Mutate: 2.926757ms
      Fitness: 665.537µs
      UpdateBestChromosome: 770.802µs
      Other: 3.386176ms
      Total: 55.564986ms

   RangeGenotype
      finish - iteration: 0
        Init: 2.676198ms
        Select: 11.464497ms
        Crossover: 75.495566ms
        Mutate: 4.736304ms
        Fitness: 977.106µs
        UpdateBestChromosome: 6.734772ms
        Other: 911.445µs
        Total: 102.995888ms

      finish - iteration: 0
        Init: 1.717173ms
        Select: 7.081651ms
        Crossover: 36.574494ms
        Mutate: 3.19718ms
        Fitness: 685.738µs
        UpdateBestChromosome: 1.015182ms
        ChromosomeDataDropAndCopy: 12.965953ms
        Total: 63.237371ms
      best_generation: 624, best fitness score: Some(0), duration: 51.600367ms


const GENES_SIZE: usize = 40000;
const POPULATION_SIZE: usize = 200;

   RangeGenotype
      finish - iteration: 0
        Init: 30.693764ms
        Select: 19.512762ms
        Crossover: 2.539280249s
        Mutate: 16.443389ms
        Fitness: 1.655913ms
        UpdateBestChromosome: 19.702243ms
        ChromosomeDataDropAndCopy: 2.02731968s
        Total: 4.654608s
      best_generation: 624, best fitness score: Some(0), duration: 2.903516571s

   RangeGenotype with ChromosomeManager-chromosome_bin
      finish - iteration: 0
        Init: 30.322953ms
        Select: 15.883884ms
        Crossover: 1.178925552s
        Mutate: 11.568932ms
        Fitness: 1.2108ms
        UpdateBestChromosome: 5.442272ms
        ChromosomeDataDropAndCopy: 416.531875ms
        Total: 1.659886268s
      best_generation: 624, best fitness score: Some(0), duration: 1.245338452s

